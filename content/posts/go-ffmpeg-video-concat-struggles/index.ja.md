---
title: "Go × FFmpegで動画連結を実装して踏んだ地雷まとめ（concat仕様・音ズレ・デッドロック）"
date: 2026-01-01T02:10:06+09:00
lastmod: 2026-01-27T22:42:00+09:00
draft: true
description: "Go言語からFFmpegを使って動画連結を実装した際に踏んだ罠をまとめました。concatの3つの仕様、再エンコード判断、os/execのデッドロック、音ズレ対策まで、実務で役立つ知見を共有します。"
summary: "Go言語からFFmpegで動画連結を実装した際のトラブル集。concat仕様の罠、デッドロック、再エンコード判断、音ズレ対策まで実務目線で解説します。"
categories: ["Go", "FFmpeg", "動画処理"]
tags: ["Go", "FFmpeg", "動画連結", "トラブルシューティング", "パフォーマンスチューニング"]
showSummary: true
showHero: true
# heroImage: "featured.webp"
---

{{< lead >}}
「Goで動画連結？ `os/exec` でFFmpeg叩くだけでしょ？ 楽勝じゃん」
<br>
……そう思っていた時期が、私にもありました。
<br><br>
これは、**Go言語からFFmpegを使って動画連結を実装しようとして踏み抜いた、実務の地雷集**です。
{{< /lead >}}

対象は、次のような人です。

- バックエンド（Go）で動画処理を実装している  
- FFmpegの `concat` を何となく使おうとしている  
- 音ズレ・壊れた動画・謎のフリーズに悩んでいる  

私自身が実務で **「仕様の罠」「処理速度の限界」「謎の音ズレ」** と戦った記録を、そのまま共有します。

## 1. 導入：なぜ Go × FFmpeg で動画連結を実装したのか

今回やりたかったのは単純です。「ユーザーがアップロードした複数の動画クリップを、バックエンド（Go）のバッチ処理で一本に結合する」こと。

AWS MediaConvert などの外部サービスを使えば安定するのは分かっていましたが、今回は **「低コスト」** かつ **「自社インフラ内で完結させたい」** という要件があり、EC2（またはコンテナ）上で **FFmpeg を直接叩く** 設計を選びました。

「コマンド一発叩くだけだし、すぐ終わるだろう」

この甘い見積もりが、地獄のデバッグ祭りの始まりでした。

## 2. 直面した主な苦労：FFmpeg の `concat` 3つの罠

この章が、この記事の一番重要なポイントです。  
**FFmpegのconcatには3種類あり、どれを選ぶかで「速さ・壊れやすさ・CPU負荷」がすべて変わります。**

FFmpeg で動画を連結（concat）する方法は1つだと思っていませんか？ 実は大きく分けて **3種類** あり、それぞれ挙動が全く違います。これを理解していなかったのが最初の躓きでした。

### ① Concat Demuxer
テキストファイルにファイルリストを書いて読み込ませる方法です。

```bash
ffmpeg -f concat -i mylist.txt -c copy output.mp4
```

*   **メリット**: 再エンコードなし（`-c copy`）で爆速。
*   **デメリット**: **「全動画のコーデック、解像度、フレームレートが完全に一致」** していないと失敗する、または壊れたファイルが生成される。

### ② Concat Protocol
`ffmpeg -i "concat:input1.ts|input2.ts" ...` のように書く方法。

*   **罠**: 基本的に MPEG-TS などのコンテナでしか使えない。MP4 をこれで行うとヘッダーがおかしくなり、再生できないファイルが生まれます。

### ③ Filter Complex Concat
`filter_complex` を使って映像と音声をストリームとして繋ぐ方法。

```bash
ffmpeg -i input1.mp4 -i input2.mp4 \
-filter_complex "[0:v][0:a][1:v][1:a]concat=n=2:v=1:a=1[outv][outa]" \
-map "[outv]" -map "[outa]" output.mp4
```

*   **メリット**: 形式が違う動画でも強制的に繋げられる。
*   **デメリット**: **必ず再エンコードが発生するため、CPU負荷が高く時間がかかる。**

---

**【私の迷走】**
最初は爆速の **① Concat Demuxer** を採用しました。しかし、ユーザーがアップロードする動画は iPhone で撮ったもの、Android で撮ったもの、ブラウザで録画したもの……全てバラバラ。
結果、結合エラーを連発し、「再エンコード必須パターン」があることに気づくまでに数日を費やしました。

## 3. Go から FFmpeg を扱う難しさ

Go の `os/exec` は強力ですが、FFmpeg のような「大量のログを吐き、長時間動き、リソースを食うプロセス」を扱うには工夫が必要です。

### エラーハンドリングが辛い
FFmpeg は、致命的なエラーでも終了コード 0 を返すことがあったり、逆に警告だけで終了コード 1 になったりと、挙動が読めません。
「成功したはずなのに、0バイトのファイルができている」なんて日常茶飯事です。

### ログの洪水とデッドロック
デバッグのために標準出力・標準エラー出力を Go で受け取ろうとしました。

```go
cmd := exec.Command("ffmpeg", args...)
cmd.Stdout = &outBuf
cmd.Stderr = &errBuf
err := cmd.Run()
```

しかし、FFmpeg は大量のログを標準エラー（stderr）に吐きます。Go のバッファがいっぱいになると、**パイプ処理がブロックして処理が永遠に終わらない（デッドロック）** 現象が発生しました。

解決策として、適切にストリームを吸い出し続ける Goroutine を立てるか、不要なログを捨てる設計が必要でした。

## 4. パフォーマンスとの戦い：CPU 100% の悪夢

「形式が違う動画は `filter_complex` で繋ごう」
そう決めた途端、今度はサーバーが悲鳴を上げました。

### 連結だけのはずが再エンコードで CPU 100%
`filter_complex` は再エンコードを行うため、CPU をフルに使います。動画が数本ならいいですが、ユーザーが増えると **CPU 使用率が常に 100% に張り付き、他の API リクエストすら捌けない状態** に。

 Cloudflare Pages や S3 に置くためファイルサイズも削りたく、圧縮率を上げるとさらにエンコード時間は伸びます。

### 解決策：-c copy を使える条件を探す
「なんでも再エンコード」は諦め、**「可能な限り copy (再エンコードなし) を使い、無理な場合だけ再エンコードする」** という分岐ロジックを実装しました。

1.  事前に `ffprobe` で全動画のコーデック、解像度、SAR/DAR を調査。
2.  全て一致している → `Concat Demuxer` (-c copy) で爆速結合。
3.  不一致がある → キューに入れて、バックグラウンドで `filter_complex` で結合。

この「仕分け」処理を入れただけで、全体の処理負荷は 1/10 以下になりました。

## 5. もっと辛かった問題：音ズレ / 破損

パフォーマンス問題が片付いて、「これでリリースできる！」と思った矢先。
**「結合した動画の後半で、音が1秒くらいズレてます」** という報告が。

### 原因：可変フレームレート (VFR) とタイムスタンプ
スマホで撮影した動画は、通信状況や処理落ちによってフレームレートが変動する **VFR (Variable Frame Rate)** であることが多いです。
これを `-c copy` で無理やり繋ぐと、音声と映像のタイムスタンプ (PTS/DTS) が徐々にズレていきます。

### 修正で使った呪文（オプション）
音ズレと戦うために、以下のオプションを試行錯誤しました。

*   `-avoid_negative_ts make_zero`: タイムスタンプが負になるのを防ぐ、基本のキ。
*   `-fflags +genpts`: タイムスタンプがないフレームに再生成を行う。
*   `setpts=PTS-STARTPTS`: フィルタを使う場合、タイムスタンプをリセットして再計算させる。

最終的には、**「再エンコード時には必ずフレームレートを固定（CFR）する」** (`-r 30` など) ことで、音ズレを根絶しました。

## 6. Go での実装方針（改善後の設計）

数々の屍を乗り越えて、最終的に落ち着いたフローがこちらです。

1.  **メタ情報取得**: `ffprobe -print_format json` で詳細な仕様を取得し、Go の struct にマッピング。
2.  **判定ロジック**: コーデック、解像度、アスペクト比が一致しているか判定。
3.  **条件分岐**:
    *   **一致**: バッファ制限を回避した `os/exec` で `-c copy` 実行。
    *   **不一致**: `filter_complex` で統一規格（H.264/AAC, 1080p, 30fps）に再エンコード。
4.  **並列数制御**: サーバーを殺さないよう、`runtime.NumCPU() / 2` 程度にセマフォで制限。
5.  **ログ保存**: 失敗時は `ffmpeg` の標準エラー出力をファイルに書き出し、後で解析できるようにする。

「最初からこの設計にしておけば……」と何度も思いましたが、失敗しないと分からないのが動画処理の怖さです。

## 7. 実務から得た教訓

> [!IMPORTANT]
> **FFmpegは「動けばOK」ではない。**

コマンドが成功しても、特定のプレイヤー（iPhoneのSafariだけ、とか）で再生できないファイルができることはよくあります。**「再生保証まで含めて検証」** が必須です。

また、Go の `os/exec` は、単にコマンドを叩く道具として使うと痛い目を見ます。
**「標準出力/エラー出力のバッファリング設計」** と **「ゾンビプロセス対策（Contextでのタイムアウト制御）」** は、実装の設計段階で組み込んでおくべきです。

もし形式チェックの自動化をサボっていたら、運用フェーズで毎日「動画が繋がらないんですけど」という問い合わせ対応に追われていたでしょう。

## 8. まとめ

Go から FFmpeg で動画連結を実装する場合、最低限押さえるべきポイントは次の通りです。

- concatの3方式（Demuxer / Protocol / Filter）の仕様を理解する  
- `ffprobe` による事前メタ情報チェックを必ず入れる  
- 可能な限り `-c copy` を使い、再エンコードは最終手段にする  
- VFR動画はCFRに正規化しないと音ズレが起きる  
- `os/exec` では標準出力・エラー出力のデッドロック対策を入れる  
- 並列実行数は必ず制御する  

FFmpegは「コマンドが通った＝成功」ではありません。  
**再生保証・パフォーマンス・運用負荷まで含めて初めて“実装完了”** だと、今回身をもって学びました。

これから Go × FFmpeg で動画処理を実装する人の、  
「最初の地雷回避」に少しでも役立てば幸いです。
