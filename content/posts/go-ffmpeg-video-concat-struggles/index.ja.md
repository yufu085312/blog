---
title: "Go × FFmpeg で動画連結に挑んで詰んだ話<br>仕様の罠、処理速度、音ズレと戦った実務メモ"
date: 2026-01-01T02:10:06+09:00
draft: false
description: "「Goで動画連結なんてos/execで叩くだけでしょ？」そう思っていた時期が私にもありました。concatの3つの仕様、再エンコードの判断、パイプ処理のデッドロック、そして謎の音ズレ……。実務で踏み抜いたFFmpegの地雷とその解決策を共有します。"
summary: "Go言語からFFmpegを扱って動画を連結しようとした際に直面した数々のトラブル（concat仕様の罠、デッドロック、音ズレなど）と、その解決策をまとめた技術記事です。"
categories: ["Go", "FFmpeg", "動画処理"]
tags: ["Go", "FFmpeg", "動画連結", "トラブルシューティング", "パフォーマンスチューニング"]
showSummary: true
showHero: true
# heroImage: "featured.png"
---

{{< lead >}}
「Goで動画連結？ `os/exec` でFFmpeg叩くだけでしょ？ 楽勝じゃん」
<br>
……そう思っていた時期が、私にもありました。
<br><br>
これは、動画処理の沼に足を踏み入れ、**「仕様の罠」「処理速度の限界」「謎の音ズレ」** と戦い続けた実務の記録です。
{{< /lead >}}

## 1. 導入：なぜ Go × FFmpeg なのか

今回やりたかったのは単純です。「ユーザーがアップロードした複数の動画クリップを、バックエンド（Go）のバッチ処理で一本に結合する」こと。

AWS MediaConvert などの外部サービスを使えば安定するのは分かっていましたが、今回は **「低コスト」** かつ **「自社インフラ内で完結させたい」** という要件があり、EC2（またはコンテナ）上で **FFmpeg を直接叩く** 設計を選びました。

「コマンド一発叩くだけだし、すぐ終わるだろう」

この甘い見積もりが、地獄のデバッグ祭りの始まりでした。

## 2. 直面した主な苦労：FFmpeg の `concat` 3つの罠

FFmpeg で動画を連結（concat）する方法は1つだと思っていませんか？ 実は大きく分けて **3種類** あり、それぞれ挙動が全く違います。これを理解していなかったのが最初の躓きでした。

### ① Concat Demuxer
テキストファイルにファイルリストを書いて読み込ませる方法です。

```bash
ffmpeg -f concat -i mylist.txt -c copy output.mp4
```

*   **メリット**: 再エンコードなし（`-c copy`）で爆速。
*   **デメリット**: **「全動画のコーデック、解像度、フレームレートが完全に一致」** していないと失敗する、または壊れたファイルが生成される。

### ② Concat Protocol
`ffmpeg -i "concat:input1.ts|input2.ts" ...` のように書く方法。

*   **罠**: 基本的に MPEG-TS などのコンテナでしか使えない。MP4 をこれで行うとヘッダーがおかしくなり、再生できないファイルが生まれます。

### ③ Filter Complex Concat
`filter_complex` を使って映像と音声をストリームとして繋ぐ方法。

```bash
ffmpeg -i input1.mp4 -i input2.mp4 \
-filter_complex "[0:v][0:a][1:v][1:a]concat=n=2:v=1:a=1[outv][outa]" \
-map "[outv]" -map "[outa]" output.mp4
```

*   **メリット**: 形式が違う動画でも強制的に繋げられる。
*   **デメリット**: **必ず再エンコードが発生するため、CPU負荷が高く時間がかかる。**

---

**【私の迷走】**
最初は爆速の **① Concat Demuxer** を採用しました。しかし、ユーザーがアップロードする動画は iPhone で撮ったもの、Android で撮ったもの、ブラウザで録画したもの……全てバラバラ。
結果、結合エラーを連発し、「再エンコード必須パターン」があることに気づくまでに数日を費やしました。

## 3. Go から FFmpeg を扱う難しさ

Go の `os/exec` は強力ですが、FFmpeg のような「大量のログを吐き、長時間動き、リソースを食うプロセス」を扱うには工夫が必要です。

### エラーハンドリングが辛い
FFmpeg は、致命的なエラーでも終了コード 0 を返すことがあったり、逆に警告だけで終了コード 1 になったりと、挙動が読めません。
「成功したはずなのに、0バイトのファイルができている」なんて日常茶飯事です。

### ログの洪水とデッドロック
デバッグのために標準出力・標準エラー出力を Go で受け取ろうとしました。

```go
cmd := exec.Command("ffmpeg", args...)
cmd.Stdout = &outBuf
cmd.Stderr = &errBuf
err := cmd.Run()
```

しかし、FFmpeg は大量のログを標準エラー（stderr）に吐きます。Go のバッファがいっぱいになると、**パイプ処理がブロックして処理が永遠に終わらない（デッドロック）** 現象が発生しました。

解決策として、適切にストリームを吸い出し続ける Goroutine を立てるか、不要なログを捨てる設計が必要でした。

## 4. パフォーマンスとの戦い：CPU 100% の悪夢

「形式が違う動画は `filter_complex` で繋ごう」
そう決めた途端、今度はサーバーが悲鳴を上げました。

### 連結だけのはずが再エンコードで CPU 100%
`filter_complex` は再エンコードを行うため、CPU をフルに使います。動画が数本ならいいですが、ユーザーが増えると **CPU 使用率が常に 100% に張り付き、他の API リクエストすら捌けない状態** に。

 Cloudflare Pages や S3 に置くためファイルサイズも削りたく、圧縮率を上げるとさらにエンコード時間は伸びます。

### 解決策：-c copy を使える条件を探す
「なんでも再エンコード」は諦め、**「可能な限り copy (再エンコードなし) を使い、無理な場合だけ再エンコードする」** という分岐ロジックを実装しました。

1.  事前に `ffprobe` で全動画のコーデック、解像度、SAR/DAR を調査。
2.  全て一致している → `Concat Demuxer` (-c copy) で爆速結合。
3.  不一致がある → キューに入れて、バックグラウンドで `filter_complex` で結合。

この「仕分け」処理を入れただけで、全体の処理負荷は 1/10 以下になりました。

## 5. もっと辛かった問題：音ズレ / 破損

パフォーマンス問題が片付いて、「これでリリースできる！」と思った矢先。
**「結合した動画の後半で、音が1秒くらいズレてます」** という報告が。

### 原因：可変フレームレート (VFR) とタイムスタンプ
スマホで撮影した動画は、通信状況や処理落ちによってフレームレートが変動する **VFR (Variable Frame Rate)** であることが多いです。
これを `-c copy` で無理やり繋ぐと、音声と映像のタイムスタンプ (PTS/DTS) が徐々にズレていきます。

### 修正で使った呪文（オプション）
音ズレと戦うために、以下のオプションを試行錯誤しました。

*   `-avoid_negative_ts make_zero`: タイムスタンプが負になるのを防ぐ、基本のキ。
*   `-fflags +genpts`: タイムスタンプがないフレームに再生成を行う。
*   `setpts=PTS-STARTPTS`: フィルタを使う場合、タイムスタンプをリセットして再計算させる。

最終的には、**「再エンコード時には必ずフレームレートを固定（CFR）する」** (`-r 30` など) ことで、音ズレを根絶しました。

## 6. Go での実装方針（改善後の設計）

数々の屍を乗り越えて、最終的に落ち着いたフローがこちらです。

1.  **メタ情報取得**: `ffprobe -print_format json` で詳細な仕様を取得し、Go の struct にマッピング。
2.  **判定ロジック**: コーデック、解像度、アスペクト比が一致しているか判定。
3.  **条件分岐**:
    *   **一致**: バッファ制限を回避した `os/exec` で `-c copy` 実行。
    *   **不一致**: `filter_complex` で統一規格（H.264/AAC, 1080p, 30fps）に再エンコード。
4.  **並列数制御**: サーバーを殺さないよう、`runtime.NumCPU() / 2` 程度にセマフォで制限。
5.  **ログ保存**: 失敗時は `ffmpeg` の標準エラー出力をファイルに書き出し、後で解析できるようにする。

「最初からこの設計にしておけば……」と何度も思いましたが、失敗しないと分からないのが動画処理の怖さです。

## 7. 実務から得た教訓

> [!IMPORTANT]
> **FFmpegは「動けばOK」ではない。**

コマンドが成功しても、特定のプレイヤー（iPhoneのSafariだけ、とか）で再生できないファイルができることはよくあります。**「再生保証まで含めて検証」** が必須です。

また、Go の `os/exec` は、単にコマンドを叩く道具として使うと痛い目を見ます。
**「標準出力/エラー出力のバッファリング設計」** と **「ゾンビプロセス対策（Contextでのタイムアウト制御）」** は、実装の設計段階で組み込んでおくべきです。

もし形式チェックの自動化をサボっていたら、運用フェーズで毎日「動画が繋がらないんですけど」という問い合わせ対応に追われていたでしょう。

## 8. まとめ

Go で FFmpeg を扱うなら、以下の覚悟が必要です。

*   concat の3つの仕様（Demuxer, Protocol, Filter）を理解する。
*   ffprobe での事前チェック判定を作る。
*   音ズレ対策（PTS/DTS, VFR対策）を知っておく。
*   `os/exec` のデッドロックと並列制御に気をつける。

ここまでやっても、未知の壊れた動画ファイルは送られてきます。
それでも、「二度とノリで os/exec からFFmpegを叩かない」と心に誓いつつ、今日も黒い画面に `ffmpeg -i` を打ち込むのです。

---
