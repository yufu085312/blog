---
title: "🔒 実務で学ぶ CSRF 対策の本質<br>「SameSite=Lax だから安心」という誤解を解く"
date: 2025-11-20T12:26:00+09:00
description: "CSRFの実装、何となくで済ませていませんか？実務での失敗経験をもとに、なぜCSRFトークンが必要なのか、SameSite属性との併用が必須な理由を分かりやすく解説します。"
summary: "認証Cookieの仕組みを悪用するCSRF攻撃。実務でのヒヤリハット事例から、現場で推奨される二重防御（CSRFトークン + SameSite）の具体的な実装方針までを一挙公開。"
categories: ["セキュリティ", "バックエンド"]
tags: ["CSRF", "セキュリティ", "Web開発", "脆弱性", "SameSite"]
showSummary: true
showHero: true
---

{{< lead >}}
私は実務で、「CSRF対策は入れているはずなのに、セキュリティレビューで即差し戻された」という経験があります。
理由は単純で、「SameSite=Lax を設定しているし、管理画面でログイン必須だから十分だろう」という思い込みでした。
{{< /lead >}}

結論から言うと、それは非常に危険な考え方でした。

CSRF（Cross-Site Request Forgery）は、**認証済みユーザーの権限をそのまま悪用する攻撃**です。実装を少し間違えるだけで、
- ユーザー情報の改ざん
- 管理操作の強制実行
- 意図しない送金や削除

といった深刻な被害につながります。

本記事では、CSRF攻撃が「なぜ成立するのか」、実務で実際に問題になったケース、そして現場で“OK”と判断される標準的な対策を、**理論＋経験ベース**で解説します。

---

## 1. CSRF攻撃とは何か

CSRFとは、**ユーザーがログイン済みであることを悪用し、本人の意思とは無関係にリクエストを送信させる攻撃**です。

{{< alert icon="triangle-exclamation" >}}
攻撃の本質は「なりすまし」ではありません。正規ユーザーのブラウザを**踏み台**にする点が最大の特徴です。
{{< /alert >}}

### CSRF攻撃が成立する3つの条件

1.  **ユーザーがログイン済みである**
    - ブラウザに認証Cookie（セッションIDなど）が保存されている状態。
2.  **攻撃者がリクエスト内容を推測できる**
    - URL、HTTPメソッド、パラメータが予測可能であること。
3.  **ブラウザがCookieを自動送信する**
    - ここが最大のポイントです。ブラウザはリクエストの正当性を判断せず、ドメインが一致すればCookieを添えてしまいます。

---

## 2. 【実例】実務でヒヤリとしたCSRF事故の芽

ある管理画面で、次のような仕様がありました。

`GET /admin/user/delete?id=123`

- 管理者のみアクセス可能
- ログイン必須

「管理者しか触れないし、認証も通しているから大丈夫」という判断でしたが、これは**NG**です。
もし管理者がログインしたまま攻撃サイトのリンクを踏むと、密かにユーザー削除リクエストが飛ばされてしまいます。

> [!IMPORTANT]
> 「認証されている」「内部向けの管理画面である」ことは、**CSRF対策を省略する理由にはならない**ということを痛感した事例です。

---

## 3. 現場で推奨される「二重防御」の標準

CSRF対策の本質は、**そのリクエストが“正規の画面から送信されたものか”を検証すること**にあります。
現代のWeb開発では、以下の組み合わせが標準です。

### 対策①：CSRFトークン（サーバーサイド検証）

サーバー側でランダムな値を生成し、フォーム等に埋め込みます。リクエスト受信時にこれが一致するかを厳格にチェックします。

| ポイント | 詳細 |
| :--- | :--- |
| **ランダム性** | 第三者が推測不可能な、十分な長さの値を生成する |
| **分離** | セッションIDそのものを使わず、CSRF専用のトークンを発行する |
| **検証** | 状態を変更する操作（POST/PUT/DELETE等）には必ず適用する |

### 対策②：SameSite Cookie 属性

ブラウザ側で「外部サイトからの遷移時にCookieを送信するか」を制御します。

- **Strict**: 最も厳格。外部からはCookieが送られません。
- **Lax**: 実務での推奨。リンク経由のトップページ遷移等、一部の安全なリクエストのみ許可します。
- **None**: 常に送信。Secure属性が必須で、CSRFリスクが最も高いです。

---

## 4. フレームワーク利用時こそ注意が必要

多くのフレームワークはCSRF対策を標準搭載していますが、以下のケースで「抜け穴」が生まれやすいです。

- **API + SPA 構成**: Cookieを使わずヘッダーで管理しているつもりでも、設計ミスで隙ができる。
- **外部ドメイン連携**: 特定のAPIだけ対策を外した結果、そこを狙われる。
- **管理画面の独自実装**: 標準機能を使わず「GETで消去」などの安易な実装をしてしまう。

> [!TIP]
> 「フレームワークがやってくれるから安心」ではなく、**仕組みを理解した上で正しく組み込むこと**が、エンジニアとしての責任です。

---

## 5. まとめ

CSRF攻撃は、Webの「自動でCookieを送信する」という基本的な仕組みを突く攻撃です。実務では、**CSRFトークンとSameSite属性の二重防御**が必須となります。

セキュリティ対策は「知らなかった」では済まされません。本記事の内容を、ぜひあなたのアプリケーション設計の見直しに役立ててください。

---

### 📘 筆者について
本記事は、バックエンド実装、セキュリティレビュー対応、CSRF対策の設計・修正を実務で経験してきたエンジニアが執筆しています。

### 関連ボタン
{{< button href="https://www.veracode.com/security/csrf" target="_blank" >}}
CSRFの更なる詳細（外部サイト）
{{< /button >}}
