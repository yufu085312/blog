---
title: "実務で学ぶCSRF対策の本質｜「SameSite=Laxで安心」は本当に正しいのか"
date: 2025-11-20T12:26:00+09:00
lastmod: 2026-01-25T21:56:00+09:00
description: "CSRFの実装、何となくで済ませていませんか？実務での失敗経験をもとに、なぜCSRFトークンが必要なのか、SameSite属性との併用が必須な理由を分かりやすく解説します。"
summary: "認証Cookieの仕組みを悪用するCSRF攻撃。実務でのヒヤリハット事例から、現場で推奨される二重防御（CSRFトークン + SameSite）の具体的な実装方針までを一挙公開。"
categories: ["セキュリティ", "バックエンド"]
tags: ["CSRF", "セキュリティ", "Web開発", "脆弱性", "SameSite"]
showSummary: true
showHero: true
---

{{< lead >}}
私は実務で、「CSRF対策は入れているはずなのに、セキュリティレビューで即差し戻された」という経験があります。  
理由は単純で、「SameSite=Lax を設定しているし、管理画面でログイン必須だから十分だろう」という思い込みでした。

しかし、この判断は**実際の攻撃シナリオをほとんど理解していなかった**ことを意味していました。

結論から言うと、それは**セキュリティレビューで落とされて当然の、極めて危険な考え方**でした。

そしてこれは、**多くの現場で今も普通に行われている誤ったCSRF対策**でもあります。

CSRF（Cross-Site Request Forgery）は、**認証済みユーザーの権限をそのまま悪用する攻撃**です。実装を少し間違えるだけで、
- ユーザー情報の改ざん
- 管理操作の強制実行
- 意図しない送金や削除

といった深刻な被害につながります。

本記事では、CSRF攻撃が「なぜ成立するのか」、実務で実際に問題になったケース、そして現場で“OK”と判断される標準的な対策を、**理論＋経験ベース**で解説します。
{{< /lead >}}

---

## 1. CSRF攻撃とは何か

CSRFとは、**ユーザーがログイン済みであることを悪用し、本人の意思とは無関係にリクエストを送信させる攻撃**です。

{{< alert icon="triangle-exclamation" >}}
攻撃の本質は「なりすまし」ではありません。正規ユーザーのブラウザを**踏み台**にする点が最大の特徴です。
{{< /alert >}}

### CSRF攻撃が成立する3つの条件

1.  **ユーザーがログイン済みである**
    - ブラウザに認証Cookie（セッションIDなど）が保存されている状態。
2.  **攻撃者がリクエスト内容を推測できる**
    - URL、HTTPメソッド、パラメータが予測可能であること。
3.  **ブラウザがCookieを自動送信する**
    - ここが最大のポイントです。ブラウザはリクエストの正当性を判断せず、ドメインが一致すればCookieを添えてしまいます。

---

## 2. 【実例】実務でヒヤリとしたCSRF事故の芽

ある管理画面で、次のような仕様がありました。

`GET /admin/user/delete?id=123`

- 管理者のみアクセス可能
- ログイン必須

「管理者しか触れないし、認証も通しているから大丈夫」という判断でしたが、これは**NG**です。
もし管理者がログインしたまま攻撃サイトのリンクを踏むと、密かにユーザー削除リクエストが飛ばされてしまいます。

> [!IMPORTANT]
> 「認証されている」「内部向けの管理画面である」ことは、**CSRF対策を省略する理由にはならない**ということを痛感した事例です。

---

## 3. なぜ「SameSite=Laxだけ」ではCSRFを防げないのか

「SameSite=Laxを設定しているから、CSRFはある程度防げているはず」  
実務では、この認識が非常に多く見られます。

確かにSameSite属性は、**“何もしないよりは”有効**です。  
しかし、これだけに依存する設計には、致命的な弱点があります。

最大の問題は、**Laxは“完全な遮断”ではない**という点です。

例えば、以下のようなケースは今でも普通に成立します。

- GETリクエストによる状態変更API  
- 外部サイトからのリンク遷移  
- 一部ブラウザの挙動差  

この場合、**攻撃者はトークンを知らなくても、Cookie付きリクエストを発生させることが可能**です。

つまり、

> SameSiteは「補助的な防御」  
> CSRFトークンは「本質的な防御」

という役割分担になります。

SameSiteだけに頼る設計は、  
「鍵をかけずに、防犯カメラだけ設置している家」と同じです。

次の章では、現場で実際に推奨されている**二重防御の正しい設計**を整理します。

---

## 4. 現場で推奨される「二重防御」の標準

CSRF対策の本質は、**そのリクエストが“正規の画面から送信されたものか”を検証すること**にあります。
現代のWeb開発では、以下の組み合わせが標準です。

### 対策①：CSRFトークン（サーバーサイド検証）

サーバー側でランダムな値を生成し、フォーム等に埋め込みます。リクエスト受信時にこれが一致するかを厳格にチェックします。

| ポイント | 詳細 |
| :--- | :--- |
| **ランダム性** | 第三者が推測不可能な、十分な長さの値を生成する |
| **分離** | セッションIDそのものを使わず、CSRF専用のトークンを発行する |
| **検証** | 状態を変更する操作（POST/PUT/DELETE等）には必ず適用する |

### 対策②：SameSite Cookie 属性

ブラウザ側で「外部サイトからの遷移時にCookieを送信するか」を制御します。

- **Strict**: 最も厳格。外部からはCookieが送られません。
- **Lax**: 実務での推奨。リンク経由のトップページ遷移等、一部の安全なリクエストのみ許可します。
- **None**: 常に送信。Secure属性が必須で、CSRFリスクが最も高いです。

---

## 5. フレームワーク利用時こそ注意が必要

多くのフレームワークはCSRF対策を標準搭載していますが、以下のケースで「抜け穴」が生まれやすいです。

- **API + SPA 構成**: Cookieを使わずヘッダーで管理しているつもりでも、設計ミスで隙ができる。
- **外部ドメイン連携**: 特定のAPIだけ対策を外した結果、そこを狙われる。
- **管理画面の独自実装**: 標準機能を使わず「GETで消去」などの安易な実装をしてしまう。

> [!TIP]
> 「フレームワークがやってくれるから安心」ではなく、**仕組みを理解した上で正しく組み込むこと**が、エンジニアとしての責任です。

---

## 6. まとめ

CSRF攻撃は、Webの「自動でCookieを送信する」という基本的な仕組みを突く、**非常に現実的で再現性の高い攻撃**です。

実務では、

- CSRFトークンによるサーバー側検証  
- SameSite属性によるブラウザ側制御  

この**二重防御が事実上の最低ライン**になります。

もしあなたのプロジェクトで、

- 「SameSiteを入れているから大丈夫」  
- 「管理画面だから安全」  
- 「フレームワーク任せだから問題ない」  

と思っている箇所があれば、**一度、実装を見直す価値は十分にあります。**

セキュリティは、事故が起きてからでは遅すぎます。  
この記事が、その“事故を未然に防ぐきっかけ”になれば幸いです。

---

### 📘 筆者について
本記事は、バックエンド実装、セキュリティレビュー対応、CSRF対策の設計・修正を実務で経験してきたエンジニアが執筆しています。

### 関連ボタン
{{< button href="https://www.veracode.com/security/csrf" target="_blank" >}}
CSRFの更なる詳細（外部サイト）
{{< /button >}}
